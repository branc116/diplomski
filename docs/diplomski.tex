\documentclass[times, utf8, diplomski]{diplomski}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{nameref}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}

\graphicspath{ {./imgs/} }

\renewcommand{\lstlistingname}{Kod}
\renewcommand{\lstlistlistingname}{Lista Kodova}
\lstset{language=C, tabsize=2}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize\small,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}

\thesisnumber{3155}

\title{Programska podrška za pouzdano prikupljanje podataka s ugradbenih sustava}

\author{Branimir Ričko}

\maketitle

\zahvala{Zahvaljujem se Lani na tome što mi je napisala cijeli diplomski. <3}

\tableofcontents

\chapter{Uvod}
Ugradbena računala nude brojne mogućnosti poboljšanja svakodnevice pojedinaca.
Njihove fizičke dimenzije i niska potrošnja čine ih dobrim kandidatom za stvaranjem uređaja i strojeva koji su pametniji on onih proizvedenih u prošlom desetljeću.
Iako je bolja budućnost veoma blizu svima nama, iako postoje ugradbena računala koja nam omogućuju izgradnju pametnijih stvari, proces izgradnje nije nimalo trivijalan.
Ovaj se rad bavi navedenim procesom i analizom pouzdanosti istog.
Opisan je postupak izrade jednostavnog sustava s ugradbenim računalom gdje je ugradbeno računalo Stm32, koje čita podatke sa senzora i iste u realnom vremenu šalje na server.
U sklopu ovog rada opisan je sustav koji sadrži ugradbeno računalo koje je povezano bluetoothom na računalo i šalje očitanja sa raznih senzora koji su povezani sa mikrokontrolerom.
Opisane su zančajke Stm32L4 mikrokontrolera.
Opisani su glavni djelovi bluetooth standarda.
Opisana je komunikacija između mikrokontrolera i bluetooth modula.
Opisani su protokoli koji se koriste u komunikaciji između mikrokontrolera i senzora koji su povezani s mikrokontrolerom.
Izgrađeno je programsko rješenje koje se izvršava na Stm32L4 mikrokontroleru.
Izgređeno je programsko rješenje koje se izvršava na računalu na kojem je pokrenut linux operacijski sustav.
Uspješno je ostvarena komunikacija programskog rješenja na mikrokontroleru i programskog rješenja na računalu.
Pouzdano se šalju podaci s akcelerometra i žiroskopskog senzora s mikrokontrolera na računalo.

\chapter{Ugradbena računala}
Ugradbena računala su računala malih dimenzija i niske potrošnje. 

\section{Stm32}
Stm32 \cite{STM32L476JG} je ugradbeno računalo. U ovom radu Stm32 koristi se kao primjer računala na kojem je moguće razvijati pouzdan sustav.

\section{Sensortile}
Sensortile \cite{sensortile} je integrirana pločica na kojoj se nalazi Stm32L4 mikrokontroler i nekoliko senzora. U ovom radu koristi se sensortile pločica kao fizičko okruženje za razvoj pouzdanog ugradbenog sustava.
 
\begin{figure}[H]
\includegraphics[scale=0.14]{tile_close.jpeg}
\centering
\caption{Sensortile plaćica}
\end{figure}

\subsection{LSM6DSM}
LSM6DSM \cite{LSM6DSM} je integrirani system-in-package koji sadrži 3D digitalni akcelerometar i gyroscope. Skala akcelerometra može biti podešena na ±2/±4/±8/±16g. Kružna brzina može biti podešena na
±125/±245/±500/±1000/±2000 stupnjeva po sekundi.

\subsection{LSM303AGR}
LSM303AGR je integrirani system-in-package koji sadrži 3D digitalni akcelerometar i 3D magnetski senzor. Skala akcelerometra je podesiva na
±2/±4/±8/±16g. Magnetski senzor ima dinamički raspon do ±50 gausa. Koristi I\(^2\)C ili SPI sučelje za komunikaciju.

\subsection{LPS22HB}
LPS22HB je integrirani system-in-package koji sadrži digitalni barometar. Koristi I\(^2\)C ili SPI sučelje za komunikaciju.

\subsection{MP34DT05-A}
MP34DT05-A je integrirani system-in-package koji sadrži digitalni mikrofon. Koristi IC sučelje.

\subsection{BlueNRG-MS}
BlueNRG-MS \cite{BlueNrgMs} je integrirani system-in-package koji sadrži Cortex-M0 ARM jezgru i mogučnost bluetooth 4.1 komunikacije.
Cijeli paket troši maksimalno 1mA za 1dBm izlazne snage. Za komunikaciju s glavnim mikrokontrolerom kositi se SPI komunikacija.

\subsubsection{Povezivanje BlueNRGa sa Stm32L4 microkontrolerom}
BlueNRG je bluetooth module koji se nalazi na Sensortile pločici. Komunicira s Stm32L4 mikrokontrolerom pomoću SPI protokola.
Svi razmjenjeni podaci između Stm32L4 mikrokontrolera i BlurNRG modula koriste format prijenosa koji sadrži zaglavlje i tijelo poruke.
Zaglavlje poruke označava koliko je okteta BlueNRG spreman primiti te koliko je okteta željan poslati. Tijelo poruke sadrži informacije definirane bluetooth sandardnom.
Postoji pet signala koji povezuju bluetooth module i Stm32 mikrokontroler:

\begin{itemize}
  \item Odabir čipa (engl. Chip select CS) Mikrokontroler stavlja na logičku nulu da označi da BlueNRG smije komunicirati.
  \item Takt (engl. Clock) Mikrokontroler odrađuje takt kojim će komunicirati
  \item Stm32 govori, BlueNRG sluša (engl. Master out, slave in)
  \item BlueNRG govori, Stm32 sluša (engl. Master in, slave out)
  \item Podaci su spremni (engl. Data ready) BlueNRG označava da su dostupni podaci koje Stm32 može pročitati.
\end{itemize}

\subsection{Povezivanje s računalom}
Kako bi ugradbeno računalo obavljalo koristan posao potrebno ga je prvo pripremiti za programiranje.
U ovom radu ugradbeno računalo koje se programira je Stm32L4, nalazi se na sensortile pločici (slika \ref{fig:plocab}.2, dalje Pločica A) koja je povezana s malo većom pločicom (slika \ref{fig:plocab}.1, dalje Pločica B.)
Pločica A i B povezane su s nestandardnim konektorom koji pinove sa Stm32L4 direktno prenosi na Pločica B.
Konektor se može vidjeti na slici \ref{fig:plocab}.5.
Pločica B na sebi sadrži st link \cite{stlink} konektor koji služi za programiranje (slika \ref{fig:plocab}.4.)
Pločica B na sebi sadrži micro USB port koji služi isključivo za napajanje (slika \ref{fig:plocab}.3.)

\begin{figure}[H]
\includegraphics[scale=0.5]{PlocicaAiB.png}
\centering
\caption{Prikaz pločice A i B jedna pored druge \cite{gettingstartedsensor}}
\label{fig:plocab}
\end{figure}

Pločica A i B nisu dovoljne za programiranje Stm32L4 mikrokontrolera. Potrebna je dodatna pločica koja je u ulozi programatora (slika \ref{fig:prog}.) U ovom radu korišten je NUCLEO-F439ZI programator
(dalje pločica C.)

\begin{figure}[H]
  \includegraphics[scale=0.5]{connection_img.png}
  \centering
  \caption{Povezivanje Stm32L4 mikrokontrolera s računalom \cite{gettingstartedsensor}}
  \label{fig:prog}
  \begin{enumerate}
    \item St link konektor na pločici C.
    \item St link konektor na pločici B.
    \item Ne standardni konektor koji povezuje pločicu A i B.
    \item Usb konektor za napajanje pločice B.
    \item Usb konektor za napajanje pločice C i programiranje Stm32L4 mikrokontrolera preko 1, 2, 3.
  \end{enumerate}
\end{figure}

\newpage

\section{Upravljanje događajima (engl. interupts)}
Cortex m procesori posjeduju specifičan načim upravljanjem događaja. Događaji su veoma bitne kod stvaranja ugradbenih sustava zato što omogućuju energetski efikasan dizajn sustava.
Umjesto aktivnog prozivanja od strane procesora \textit{nalazi li se što na nekoj sabirnici}, procesor može biti na hardverskoj razini obaviješten da je neka sabirnica promjenila stanje.
Kad se dogodi neki događaj izvodi se sljedeća procedura:

\begin{itemize}
  \item dovrši trenutnu instrukciju.
  \item spremi trenutno stanje procesora na stog.
  \item postavi LR registar na vrijednost \textbf{0xFFFFFFF9} (označava da procesor obrađuje događaj.)
  \item postavi IPSR registar na vrijednost broja događaja.
  \item postavi PC registar na lokaciju procedure koja obrađuje specifičan događaj.
\end{itemize}

\subsubsection{xPSR registar}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{c|c|c|c|c||c||c||c|}
      \cline{2-8} & 31 & 30 & 29 & 28 & 24 & 9 & 5-0\\
      \hline
      \multicolumn{1}{|c|}{APSR} & N & Z & C & V & \multicolumn{3}{c|}{ } \\
      \hline
      \multicolumn{1}{|c|}{IPSR} & \multicolumn{6}{c||}{ } & Broj iznimke \\
      \hline
      \multicolumn{1}{|c|}{EPSR} & \multicolumn{4}{c||}{ } & T & a & \\
      \hline
    \end{tabular}
    \caption{Sadržaj xPSR registra}
  \end{center}
\end{table}

\newpage

\chapter{Bluetooth}

Bluetooth \cite{core41} je otvoren protokol koji definira bežični prijenos podataka na fizičkom sloju na sloju veze i mrežnom sloju.
Postoje komunikacijski standardi koji zahtjevaju središnji uređaj na koji se povezuju svi ostali urađaji i kroz koji teče sva komunikacija između svakog para uređaja.
Bluetooth standard je osmišljen na načina da se dva uređaja povezuju i komuniciraju direktno jedan s drugim, bez korištenja središnjeg uređaja.

\section {Fizička Razina}
Na fizičkoj razini bluetooth protokol koristi Gausijansku binarnu digitalnu frekvencijsku modulaciju (engl. GBFSK modulation) \cite{GBFSK}.
GBFSK je diskretna modulacija sa dva stanja (1 bit/simbol.)
Za razliku na od ostalih diskretnih modulacija s više diskretnih područja, binarna digitalna modulacija otpornija je na šumove i zahtjeva manju snagu za prijenos jednog simbola.
WiFi 7 standard podržavat će digitalnu modulaciju s 4096 diskretnih stanja \cite{wifimax} (12 bita/simbol.)
Cijena koju će novi WiFi standard platiti kompiciranijom modulacijom je smanjena otpornost na šum i kompliciranija izvedba uređaja.
Cijana koju bluetooth protokol plaća s jednostavnijom modulacijom je manja teoretska propusnost.
Teoretska propusnost bluetooth 4.2 LE protokola je 1Mbit/s \cite{maxtrough} dok će WiFi 7 protokol podržavati teoretsku propusnost od 46 Gbit/s.
Na podatkovnoj razini propusnost od 1Mbit/s s bluetoothom 4.2 LE protokolom nije ostvariva zbog potreba sinkronizacije, enkripcije, konzistentnosti, pouzdanosti i proširovosti koje bluetooth standard osigurava.
Uzevši u obzri sve ne podatkovne informacije potrebne za ispravan rad bluetooth protokola, maksimalna teoretska propusnot je 508Kbit/s.
U ovom radu s BlueNRG modulom maksimalna ostvarena propusnost je 25Kbit/s.
Autor rada predpostavlja da je za efikasnost od samo 5\% kriva loša implementacija bluetooth protokola na razini BlurNRG \textit{firmwarea}.
Autor rada nema pristup izvornom kodu na toj razini pa ne može potvrditi tu predpostavku.

\section{Bluetooth GAP, GATT, L2CAP, HCI, ACI}
Bluetooth standard definira podsustave koje moraju implementirati svi uređaji koji podržavaju bluetooth. Neki važniji su definirani u ovom odlomku.

\subsubsection{GAP}
Bluetooth \textbf{G}eneric \textbf{A}ccess \textbf{P}rofile.
Gap definira uloge (engl. roles) u bluetooth standardu. Uloge koje postoje su oglašivač (engl. Advertizer), skener (engl. Scanner), sporedna (engl. Slave) i glavna (engl. Master). Oglašivačka i skener uloga vrše razmjenu informacija isključivo u smjeru od oglašivača do skenera. Isto tako, nije potrebno eksplicitno spajanje uređaja.
Više skenera može slušati jednog oglašivača.

\subsubsection{GATT}
Bluetooth \textbf{G}eneric \textbf{ATT}ribue Profile definira koji podaci postoje na pojedinim bluetooth uređajima. Definira na način da svaki uređaj ima svoje servise koje su identificirani s jedinstvenim brojem (engl. UUID). UUID može biti veličine 16 okteta ili 2 okteta. Neki brojevi su rezervirani u bluetooth standardu \cite{core41}.
Dodatno GATT definira da svaki servis sadrži svoje karakteristične tokove (engl. characteristic stream) koji su isto tako identificirani jedinstvenim brojevima. Svaki karakteristični tok dodatno sadrži informaciju o tome sto je li taj tok namjenjen za pisanje ili čitanje, može li se oglašavati na tom toku, veličinu podatka jednog elementa tog toka. Primjer definicije jednostavnog servisa koji definira bateriju nekog uređaja prikazan je na slici \ref{fig:gattexample}

\begin{figure}[H]
\includegraphics[width=\textwidth]{examplegatt_20230623_212042.png}
\centering
\caption{Tablica GATT servisa i karakterističnih tokova koji definiraju bateriju nekog uređaja}
\label{fig:gattexample}
\end{figure}

U ovom radu nije korišten niti jedan standardni servis. Standardni servisi tek postaju korisni, ako korisnik želi izgraditi uređaj koji će biti prepoznat od strane svih ostalih uređaja.

\subsubsection{L2CAP}
L2CAP je bluetooth standard koji definira na koji način će dva bluetooth uređaja razmjenjivati poruke na razini poveznice.

\subsubsection{HCI}
\textbf{H}ost \textbf{C}ontroller \textbf{I}nterface je bluetooth standard koji definira u kojem se formatu razmjenjuju podaci od računala/mikrokontrolera do bluetooth modula.

\subsubsection{ACI}
\textbf{A}pplication \textbf{C}command \textbf{I}interface je standard kojeg definira kompanija STMicroelectronics i koristi se kao sloj apstrakcije nad HCI slojem na STM-ovim mikrokontrolerima.


\subsection {Razmjena podataka na između glavne i sporedne uloge}
Glavan i sporedna uloga zahtjevaju eksplicitno povezivanje (engl. pairing) Nakon povezivanja moguće je razmjenjivati poruke. Poruke je moguće razmjeniti na nekoliko načina:

\begin{itemize}
  \item Pisanje u karakteristični tok (engl. characteristic stream) i čitanje iz istog.
  \item Oglašavanje promjena u karakterističnom toku.
  \item Oglašavanje promjena u karakterističnom toku uz potvrdu o primitku oglasa.
\end{itemize}

Pisanje i čitanje iz karakterističnih tokova zahtijeva dodatnu logiku za osiguranje prijenosa svih poruka. Ovaj načina prijenosa radi na principu prozivanja. Klijent koji čita podatak i bez dodatne intervencije ne daje do znanja drugoj strani da je pročitao podatak.

\subsection {Oglašavanje promjena}
Razmjena poruka može se ostvariti oglašavanjem poruka. Oglašavanje poruka ostvaruje se na način da prilikom povezivanja uređaji sinkorniziraju satove i u točno određenim trenucima razmjene izmijenjene poruke. Dodatno protokol bez intervencije korisnika koristi dvosmjernu komunikaciju za osiguravanje prijenosa poruke. Time se osigurava da će poruka biti isporučena. Dodatno, bez intervencije korisnika, na svaku poruku dodaje se CRC čime se osigurava točnost poruke.

\chapter{Programsko rješenje}
U sklopu ovog rada izgrađeno je programsko rješenje koje se sastoji od djela koji se pokreće na Stm32L4 mikrokontroleu i djela koji se pokreće na računalu s Linux operacijskim sustavom.
Programsko rješenje očitava podatke sa senzora koji su povezani sa Stm32L4 mikrokontrolerom i te iste podatke prenosi na računalo korištenjem bluetooth protokola.
U realnom vremenu računalo grafički iscrtava iste te podatke.

\section{Programsko rješenje za Stm32L4 mikrokontroler}
Programsko rješenje za Stm32L4 mikrokontroler pisano je u programskom jeziku C.
Na visokoj razini rješenje inicijalizira komunikacijeske kanale prema senzorima i prema BlueNRG modulu.
Nakon toga pokreče se inicijalizira postavki na BlueNRG modulu i BlueNRG se povezuje sa računalom.
Nakon povezivanja počinju se očitavati vrijednosti senzora i isti podaci se prosljeđuju povezanom računalu.

U ovom radu postoje tri stanja u kojima se može nalaziti BlueNRG:

\begin{itemize}
  \item Ne inicijaliziran
  \item Inicijaliziran
  \item Povezano
\end{itemize}

\subsection{Ne inicijalizirano stanje BlueNRG-a}
Prilikom svakog ponovnog pokretanja, BlueNRG module se nalazi u \textbf{ne inicijaliziranom} stanju. Sve interne vrijednosti postavljene su na inicijalne vrijednosti. Za ispravan rad BlueNRG modula potrebno je promjeniti neke vrijednosti. U ovom radu BlueNRG je u glavnoj ulozi. Postupak postavljanje BlueNRGa u glavnu ulogu u ovom radu izvršavaju se koraci opisani u kodovima od \ref{firstinit} do \ref{lastinit}.

\begin{lstlisting}[caption={Postavi MAC adresu}, label={firstinit}]
aci_hal_write_config_data(CONFIG_DATA_PUBADDR_OFFSET,
  CONFIG_DATA_PUBADDR_LEN, bdaddr);
\end{lstlisting}

\begin{lstlisting}[caption={Inicijaliziraj gatt podsustav}]
aci_gatt_init();
\end{lstlisting}

\begin{lstlisting}[caption={Inicijaliziraj gap podsustav}]
aci_gap_init_IDB05A1(GAP_PERIPHERAL_ROLE_IDB05A1, privary_enabled, device_name_len, &service_handle, &dev_name_char_handle, &appearance_char_handle);
\end{lstlisting}

\begin{lstlisting}[caption={Postavi ime kojim će se predstavljati ostalim bluetooth uređajima.}]
aci_gatt_update_char_value(state->service_handle,
  state->dev_name_char_handle,
  0, sizeof(name) - 1, (uint8_t *)name);
\end{lstlisting}

\begin{lstlisting}[caption={Postavi autentifikacijske zahtjeve}]
aci_gap_set_auth_requirement(
  MITM_PROTECTION_NOT_REQUIRED, // uint8_t mitm_mode,
  OOB_AUTH_DATA_ABSENT,         // uint8_t oob_enable,
  NULL,                         // uint8_t oob_data[16],
  7,                    // uint8_t min_encryption_key_size,
  16,                   // uint8_t max_encryption_key_size,
  USE_FIXED_PIN_FOR_PAIRING,    // uint8_t use_fixed_pin,
  123456,                       // uint32_t fixed_pin,
  BONDING,                      // uint8_t bonding_mode
);
\end{lstlisting}

\begin{lstlisting}[caption={Postavljanje sevisa koji sadrži karakteristične tokve}]
aci_gatt_add_serv(UUID_TYPE_128,
  service_uuid, PRIMARY_SERVICE,
  number_of_char_streams, &service_id);
\end{lstlisting}

\begin{lstlisting}[caption={Postavljanje karakterističnih tokova}]
aci_gatt_add_char(serviceHandle,
  UUID_TYPE_16,
  char_uuid,
  20,               // Velicina poruke
  CHAR_PROP_NOTIFY, // Komunikacija obavjestima
  security_flags,
  GATT_NOTIFY_ATTRIBUTE_WRITE,
  16,               // encryKeySize
  false,            // Is length variable
  &charHandle
);
\end{lstlisting}

\begin{lstlisting}[caption={Postavi snagu odašiljača}]
aci_hal_set_tx_power_level(1, 7);
\end{lstlisting}

\begin{lstlisting}[caption={Postavi odgovor na poruku otkrivanja (engl. discover message)}]
// Ne odgovoraj
hci_le_set_scan_resp_data(0, NULL);
\end{lstlisting}

\begin{lstlisting}[caption={Postavi stanje BlueNRGa u stanje u povezivo stanje}, label={lastinit}]
aci_gap_set_discoverable(
  ADV_DATA_TYPE,     // uint8_t AdvType,
  ADV_INTERV_MIN,    // uint16_t AdvIntervMin,
  ADV_INTERV_MAX,    // uint16_t AdvIntervMax,
  PUBLIC_ADDR,       // uint8_t OwnAddrType,
  NO_WHITE_LIST_USE, // uint8_t AdvFilterPolicy,
  9,                 // uint8_t LocalNameLen,
  "\nBlueNRG",       // const char *LocalName,
  0,                 // uint8_t ServiceUUIDLen,
  NULL,              // uint8_t* ServiceUUIDList,
  0,                 // uint16_t SlaveConnIntervMin,
  0,                 // uint16_t SlaveConnIntervMax
);
\end{lstlisting}
\ \

Nakon uspješnog izvršavanja navedenog postupka, BlueNRG prelazi u \textbf{inicijalizirano} stanje.

\subsection{Inicijalizirano stanje BlueNRGa}
U \textbf{inicijaliziranom} stanju nema komunikacije između BlueNRG i Stm32 mikrokontrolera sve dok se BlueNRG ne poveže s nekim poduređajem. Nakon što se BlueNRG poveže s poduređajem, BlueNRG generira događaj kojim obavještava Stm32 mikrokontroler da se stanje može postaviti u \textbf{povezano}.

\subsection{Povezano stanje BlueNRGa}
Nakon povezivanja bez eksplicitnog zahtjeva, razmjene se poruke između BlueNRGa i poduređaja koji je na njega povezan. Specifično razmjenju se poruke o maksimalnoj veličini poruke (engl. MTU), način enkripcije, definicija servisa i karakterističnih tokova. Nakon razmjene tih poruka. Stm32 mikrokontroler može početi slati poruke s mjernim podacima. Procedura slanja u ovom radu je definirana na sljedeći način:

\begin{enumerate}
  \item Odredi koji će se karakteristični tok sljedeći slati
\begin{lstlisting}[caption = {Procedura za odabir karakterističnog toka koji će sljedeći biti poslan}]
int blue_send_next(blue_char_collection_t* coll, int len) {
  if (coll->waiting_for_confirm != -1) return -1;
  int i = coll->last_sent;
  int n = len;
  while(n > 0) {
    ++i;
    i %= len;
    if (coll->streams[i].send_ticks < uwTick && !is_empty(i)) {
      coll->waiting_for_confirm = i;
      coll->last_sent = i;
      ++coll->sent_packets;
      return blue_send_char_stream(&coll->char_streams[i], i);
    }
    --n;
  }
  return -1;
}
\end{lstlisting}
  \item Čekaj odgovor BlueNRGa je li poruka uspješno poslana.
    \begin{enumerate}
      \item Ukoliko je uspješno poslana, vrati se na korak 1.
      \item Ukoliko nije uspješno poslana, pošalji istu poruku ponovno i vrati se na korak 2.
    \end{enumerate}
\end{enumerate}


\subsection{Performanse BlueNRG modula}

Mjerenje propusnosti BlueNRG modula mjereno je na korištenjem programa Wireshark \cite{wireshark}. Nakon povezivanja, wireshark prikuplja dolazne podatke 100 sekundi te su nakon toga izbrojene poruke. U tablici \ref{perftable} nalaze se mjerenja koja su izvršena. Na slici \ref{fig:wireshark} prikazao je jedno mjerenje.

\begin{table}[H]
  \begin{center}
    \begin{tabular}[c]{l|l|l|l}
      \hline
      \multicolumn{1}{c|}{\textbf{Broj tokova}} &
      \multicolumn{1}{c}{\textbf{Veličina poruke (bajt)}} &
      \multicolumn{1}{c}{\textbf{Poruka/sekunda}} &
      \multicolumn{1}{c}{\textbf{Bajt/sekunda}} \\
      \hline
      1 & 16 & 142 & 2272 \\
      1 & 20 & 144 & 2880 \\
      2 & 20 & 162 & 3240 \\
      \hline
    \end{tabular}
  \caption{Bluetooth performanse}
  \label{perftable}
  \end{center}
\end{table}

\begin{figure}[H]
\includegraphics[width=\textwidth]{wireshark_100sec_20230622_225645.png}
\centering
\caption{Prikaza mjerenja korištenjem programa Wireshark \cite{wireshark}}
\label{fig:wireshark}
\end{figure}

U ovom radu testirano je nekoliko konfiguracija veličina paketa i broja tokova. Ukupna propusnost ne mijenja se značajno dodavanjem dodatnih tokova. Maksimalno kašnjenje nije mjereno, no pretpostavka je da nije veća od intervala spajanja (engl. connection interval.) Interval spajanja definira poduređaj. U ovom radu bio je pet milisekundi.


\subsection{Ugrađeni program na Mikrokontroleru}
Ugrađeni program (engl. firmware) za mikrokontroler pisan je u programskim jezicima C i C++. Pisan je na načina da se sva komunikacija s bluetooth BlueNRG modulom izvršava unutar događaja (engl. interupt). Nije korišten operativni sustav. Čitanje podataka sa senzora odvija u glavnoj petlji programa. Postoji \textbf{prvi unutra, prvi van} (engl. FIFO) struktura koja osigurava da se čitanje novih podatak sa senzora može odvijati neovisno o slanju istih bluetoothom. Ista struktura opisana je kodom \ref{codefifo}.

\begin{lstlisting}[language=c++, caption={FIFO struktura koja omgučuje neovisan dohvat novih podataka i slanje najstarijih}, label={codefifo}]
template<class T, size_t buffSize>
struct CircBuffer {
  T& push(T el) {
    auto& ret = buffer[pos++] = el;
    if (pos >= buffSize) pos = 0;
    if (len < buffSize) ++len;
    return ret;
  }
  T pop() {
    int index = (pos - len + buffSize) % buffSize;
    auto ret = buffer[index];
    if (len > 0) --len;
    return ret;
  }
  const T& peek() {
    int index = (pos - len + buffSize) % buffSize;
    return buffer[index];
  }
  size_t pos = 0;
  size_t len = 0;
  T buffer[buffSize] = {};
};
\end{lstlisting}

\subsubsection{Podatkovni protokol}
Sva podatkovna komunikacija se odvija od smjera mikrokontrolera do računalne aplikacije. Korisiti se više karakterističnih tokova (engl. caracteristic stream), svaki koristi način komunikacije s obavijestima, svaki obavještava s točno 20 podatkovnih okteta, svaki šalje točno dvije vrste poruka. Jednom u tri sekunde kroz svaki tok šalje se kontrolna poruka, a ostatak vremena šalje se podatkovna poruke. Niti jedan oktet kontrolne poruke ne sadrži vrijednost \textbf{(N \% 2) * 0xFF} osim zadnja tri okteta. Zadnja tri okteta kontrolne poruke opisuju strukturu podatkovnih poruka na način koji je definiran sljedećom tablicom.

\begin{table}[H]
  \begin{center}
    \begin{tabular}[c]{l|r}
      \multicolumn{1}{c|}{\textbf{Vrijednost opisnog okteta}} & 
      \multicolumn{1}{c}{\textbf{Definicija opisnog okteta}} \\
      \hline
      0b0000 & Podatak ne postoji \\
      0b0100 & jedan uint16 \\
      0b0110 & jedan int16 \\
      0b1000 & dva uint16 \\
      0b1010 & dva int16 \\
      0b1100 & jedan uint32 \\
      0b1110 & jedan int32 \\
      0b1111 & jedan float32 \\
      \hline
    \end{tabular}
  \caption{Značenje svake polovice okteta zadnjih tri okteta kontrolne poruke}
  \end{center}
\end{table}

Jedna od poruka koja se šalje je poruka koja sadrži podatke prikupljene s žiroskopskog senzor LSM6DSM. Struktura koja se puni opisana je u kodu \ref{codereadout}:

\begin{lstlisting}[caption = {Definicija strukure koja se šalje bluetoothom}, label={codereadout}]
 struct [[gnu::packed]]  GyroReadout {
  uint16_t temperature;
  int16_t acceleration[3];
  int16_t angular[3];
};
struct [[gnu::packed]]  GyroReadoutBLE {
  GyroReadout ro;
  uint16_t index;
  uint32_t timestamp;
};
\end{lstlisting}

Navedena struktura puni se svakih 10 milisekundi pozivom metode navedene u kodu \ref{codegetreadout}.

\begin{lstlisting}[language=c++, caption={Dohvaćanje očitanja s LSM6DSM senzora}, label={codegetreadout}]
GyroReadoutBLE get_readout(void) {
  GyroReadout ro{};
  spi_read(LSM6DSM_ACC_GYRO_OUT_TEMP_L,
    (uint8_t*)(&ro), sizeof(ro));
  return {ro, index++, uwTick}; // uwTick is global variable
                                // that is incremented in 
                                // some interupt every 1ms.
}
\end{lstlisting}

Uzevši u obzir tipove vrijednosti od kojih se sastoji struktura \textit{GyroReadoutBLE} funkcija u kodu \ref{codecontroll} puni kontrolnu poruku za tok koji šalje GyroReadoutBLE podatke.

\begin{lstlisting}[language=c++, caption={Funkcija koja puni kontrolnu poruku za žiroskopske podatke}, label={codecontroll}]
void fill_controll_message_gyro(uint8_t* buff) {
  for (int i = 0; i < 17; ++i) {
    buff[i] = (i % 2) * 0xFF;
  }
  buff[17] = 0x4A; //uint16, 2*int16
  buff[18] = 0xAA; //2*int16, 2*int16
  buff[19] = 0x4C; //uint16, int32
}
\end{lstlisting}

\section{Bluetooth na linux operativnom sustavu}
Za testiranje pouzdanosti i kvalitete prijenosa preko bluetootha potrebo je softversko rješenje koje pokreče na računalu. U ovom radu korišteno je rješenje koje se izvršava na Linux operativnom sustavu. Navedeni su neki softverski paketi koji olakšavaju rad s bluetooth uređajima u Linux okolini.

\begin{table}[H]
  \begin{center}
    \begin{tabular}[c]{l|r}
      \multicolumn{1}{c|}{\textbf{Paket}} & 
      \multicolumn{1}{c}{\textbf{Opis paketa}} \\
      \hline
      dbus & Multipleksiranje komunikacije s jednim bluetooth uređajem \\
      bluez-utils & Pomoćni programi za ispitivanje bluetooth protokola \\
      bluez-libs & Biblioteke implementacijom raznih bluetooth protokola \\
      bluez & Servis za automatsko upravljanje bluetooth adapterima \\
      \hline
    \end{tabular}
  \caption{Lista paketa potrebnih za ispravan rad bluetootha na linux os-u}
  \end{center}
\end{table}

\subsubsection{Aplikacija}
Sama aplikacija na strani računala podijeljena je na dva djela. Prvi dio pisan je u programskom jeziku python. Jezgra prvog djela je preuzeta od poznate python biblioteke \cite{ble-serial}. Svrha prvog djela je spajanje bluetoothom na uređaj i slušanje oglasa o promjeni stanja koje mjenja uređaj. Dodatno prvi dio aplikacije prosljeđuje blago formatirane podatke drugom djelu aplikacije preko UDP protokola \cite{firstPart}. Drugi dio aplikacije prikuplja podatke od prvog djela i iste podatke grafički iscrtava \cite{secondPart}. Razlog razdvajanja aplikacije je to što programski jezik C pruža okruženje u kojem je moguće kreirati responzivno sučelje za grafički prikaz, a programski jezik python omogućuje izrazito jednostavnu komunikaciju korištenjem bluetooth protokola.

\subsubsection{Prvi dio aplikacije}
Prvi dio aplikacije napravljen je vrlo jednostavno. Kreira se UDP socket kao sto je prikazano u kodu \ref{pyudpsock}. Pošalje se zahtijev preko dbus sustava da se bluetoothom želi povezati s mikrokontrolerom kao sto je prikazano u kodu \ref{pyconnect}. Nakon toga se pretplati na sve obavijesti sa svih servisa i karakterističnih tokova na mikrokontroleru kao sto je prikazanu u kodu \ref{pysubscribe}. Prilikom svake obavijesti, izvršava se funkcija koja prosljeđuje dobivene podatke drugom dijelu aplikacije (kod \ref{relay}).

\begin{lstlisting}[language=python, caption={Kreiranje udp socketa u pythonu}, label={pyudpsock}]
client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
client_socket.settimeout(1.0)
addr = ("localhost", 42069)
\end{lstlisting}

\begin{lstlisting}[language=python, caption={Spajanje bluetoothom na microkontroler}, label={pyconnect}]
ble = BLE_interface("hci0", None)
ble.set_receiver(receive_callback)
await ble.connect("02:80:E1:00:00:AA", "public", 16.0)
\end{lstlisting}

\begin{lstlisting}[language=python, caption={Pretplaćivanje na sve obavijesti sa svih servisa i karakterističnih tokov na microkontroleru}, label={pysubscribe}]
self.read_char = self.find_all_char(read_uuid)
r = [asyncio.Task(self.dev.start_notify(r, self.handle_notify)) for r in self.read_char]
await asyncio.wait(r)
\end{lstlisting}

\begin{lstlisting}[language=python, caption={Prosljeđivanje dobivene bluetooth vrijednosti drugom dijelu aplikacije}, label={relay}]
p = DBParser()
def receive_callback(handle: BleakGATTCharacteristic, value: bytes):
    p.add_data(handle.handle, value)
    d = p.pop_data() # group_id, value 
    while d != None:
        client_socket.sendto(f"{d[1]};{d[0]}".encode(), addr)
        d = p.pop_data()
\end{lstlisting}

\subsubsection{Drugi dio aplikacije}
Drugi dio aplikacije nije povezan s bluetooth. Rađen je iz razloga što je bilo potrebno validirati na neki način dobivene podatke. Grafički prikaz podataka taj zadatak drastično olakšava. Slika \ref{fig:graph} prikazuje stanje drugog dijela aplikacije nakon nekoliko sekundi od početka prikupljanja podataka. 

\begin{figure}[H]
\includegraphics[width=\textwidth]{rlplot_allsensors_20230623_120537.png}
\centering
\caption{Prikaz drugog dijela aplikacije koja iscrtava vrijednosti senzora u realnom vremenu}
\label{fig:graph}
\end{figure}

Rad cijelog sustava prikazan je u videu na adresi \url{https://youtu.be/AVqU0vSDVG8} \cite{videodemo}.

Izvorni kod programa za mikrokontroler, prvog i drugog dijela aplikacije, dokumentacija i sve ostale skripte dostupne su u git repozitoriju na adresi \ \url{https://github.com/branc116/diplomski}.

\newpage

\chapter{Razvojno okruženje}
U ovom radu korišteno je slobodno i otvoreno razvojno okruženje (engl. FLOSS \cite{FLOSS}). Integrirana okruženja poput Stm32CUBE omogućuju brz razvoj programskog rješenja. Cijena brzog razvoja nije direktno novčana, često takva integrirana razvojna rješenja imaju cijenu od 0€. Valuta plaćanju kod korištenja takvih sustava je sloboda. Sloboda mijenjanja kompanije čiji se mikrokontroleri koriste. Jednom kad se programsko rješenje razvije u jednom od ne slobodnih integriranih okruženja, teško je to isto rješenje preformulirati da radi na uređajima koje proizvodi druga firma \cite{VENDORLOCKIN}. Dodatna cijena koja se plaća korištenjem specifično Stm32CUBE integriranog okruženjem je generiran kod koji nije zadovoljavajući. Naime, Stm32CUBE često generira kod koji je previše općenit i rezultira većom potrošnjom memorije, sporijim izvođenjem i lošijoj čitljivošću. Primjer takvog koda prikazan je u \ref{badcode}.

\lstinputlisting[caption={Primjer generiranog koda kojeg generira Stm32CUBE IDE}, label={badcode}, basicstyle={\ttfamily\footnotesize\tiny}]{shitcode.c}

Svrha navedenog generiranog isječka koda je čitanje jednog okteta koji označava ime spi pod uređaja. Postoji pet indirekcija između pozivatelja funkcije i krajnje funkcije koja izvršava logiku čitanja tog okteta. Također prilikom svakog poziva zadnje funkcije provjerava se koristi li se SPI ili I\(^2\)C. Provjera koji protokol se koristi izvršava se i kod svakog drugog poziva prema spi poduređaju. Dodatno, niti jedan poduređaj nije moguće spojiti ni na koji drugi način osim korištenjem SPI protokola.

\subsubsection{cmake}
Cmake je programski alat koji je koristan za definiranje koraka potrebnih za izgradnju projekta. U ovom radu koristi se za izgradnju ugrađenog program (engl. firmware.) Cmake olakšava definiranje ovisnosti između jedinica prevođenja (engl. compilation units.) Definiranje koje jedinice je potrebno prevesti ako se promjeni \textbf{header} datoteka. Dodatno osigurava konzistentnost postavljanja zastavica u različitim jedinicama prevođenja.

\subsubsection{make}
GNU make je programski alat za definiranje \textit{recepta} i kako izgraditi pojedini element sustava. U ovom projektu koristi se za automatizaciju, ne više od, pet \textbf{shell} naredbi koje se moraju izvršiti za gradnju neke komponente sustava. Primjer make recepta koji gradi ovu dokumentaciju pokretanjem \LaTeX \cite{ungar2002uvod} naredbi prikazan je u kodu \ref{lst:make}. Recept se čita ovako: \textit{Za izgradnju pdf-a potreban je tex file. Ako je tex datoteka novija od pdf datoteke pokreni naredbe koje su ispod.} GNU make je besplatan alat s otvorenim izvornim kodom.

\begin{lstlisting}[language=make, label={lst:make}, caption={Gradnja dokumentacije korištenjem make recepta}]
build/docs/diplomski.pdf: docs/diplomski.tex
	cd docs && cp -R * ../build/docs && cd ../build/docs && pdflatex -mltex diplomski.tex && bibtex diplomski && pdflatex -mltex diplomski.tex
\end{lstlisting}

\subsubsection{OpenOCD}
OpenOCD \cite{openocd} je program koji se koristi za prebacivanje izvrsne datoteke na mikrokontroler. Uz to omogućuje stvaranje GDB servera na koji moguće povezati s običnim GDB klijentima. OpenOCD je besplatan alat s otvorenim izvornim kodom.

\subsubsection{GDB}
GNU GDB \cite{gdb} je program koji pomaže programeru otkriti greške u kodu. GDB je besplatan alat s otvorenim izvornim kodom.

\subsubsection{GCC Arm}
GCC Arm \cite{armgcc} je alat koji pomaže programeru pretvoriti izvorni kod pisan u C programskom jeziku u binarni format kojeg je u konačnici moguce pokrenuti na mikrokontrolerima s ARM procesorom. Ustvari ovo je samo druga verzija(engl. fork) GCC \cite{gcc} programa, verzija koja je specijalizirana za ARM procesore.

\chapter{Zaključak}
Stvaranje pouzdanog sustava zahtijeva poznavanje svake komponente sustava.
Bez poznavanja svake komponente nemoguće je donijeti zaključak radi li sustav ispravno.
Upoznavanje se svakim dijelom sustava iziskuje najviše vremena. Koristenje gotovih riješenja može ubrzati proces gradnje, ali bez razumijevanja svih komponenti gotovih riješenja teško se može razmatrati pouzdanost.
S druge strane stvaranje proizvoda iziskuje puno vremena, dubinsko upoznavanje svih komponenta dodatno usporava proces gradnje. Potrebno je ponekad pouzdati se u gotove djelove sustava i zanemariti pouzdanost. Zbog svega navedenog, stvaranje pouzdanih sustava nije nimalo jednostavno, ali proces gradnje je zanimljiv i uvijek postoji nova stvar koja se može izučiti.

\nocite{*}
\bibliographystyle{diplomski}
\bibliography{diplomski}

\listoffigures

\lstlistoflistings


\begin{sazetak}
Ugradbena računala nude brojne mogućnosti poboljšanja svakodnevice pojedinaca. Njihove fizičke dimenzije i niska potrošnja čine ih dobrim kandidatom za stvaranjem uređaja i strojeva koji su pametniji on onih proizvedenih u prošlom desetljeću. Iako je bolja budućnost veoma blizu svima nama, iako postoje ugradbena računala koja nam omogućuju izgradnju pametnijih stvari, proces izgradnje nije nimalo trivijalan. Ovaj se rad bavi navedenim procesom i analizom pouzdanosti istog.

\kljucnerijeci{Ugradbena računala, Pouzdanost, Bluetooth, Stm32}
\end{sazetak}

\engtitle{Software support for data collection from embedded devices with high availability}

\begin{abstract}
Embedded computers offer number of features that can augment day to day existence of every individual. Their dimensions and power efficiency make them great candidate for making a world a better place. Even thou embedded devices exist and are available to everyone, creating a system that uses that device is not trivial. This work touches on those processes and analysis of availability of those processes.

\keywords{Embedded Computers, Availability, Bluetooth, Stm32}
\end{abstract}

\end{document}
